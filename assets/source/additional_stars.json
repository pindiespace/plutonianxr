

rotate sub-objects in star system
rotate sub-objects in planetary system

USE TAG SYSTEM
https://doc.babylonjs.com/resources/tags
var myJSObj = {};
// enable tags for myJSObj
BABYLON.Tags.EnableFor(myJSObj);

// disable tags for myJSObj
BABYLON.Tags.DisableFor(myJSObj);
===================================

MeshWriter (create letters as meshes)
https://doc.babylonjs.com/extensions/mesh_writer_introduction
===================================
    var text = "BabylonJS Roxxx";
    var font = "normal 56px Arial";
    var tx = new BABYLON.DynamicTexture("dt", {width:500, height: 40}, scene);
    tx.hasAlpha = true;
    var clearColor = "transparent";
    var clearColor = "white";
    tx.drawText(text, null, 45, font, "blue", clearColor, true, false);
    tx.drawText("CLICK = BOOM", null, 60, "normal 18px Arial", "red", null, true, true);

    var mat = new BABYLON.StandardMaterial("mat1", scene);
    mat.diffuseTexture = tx;
    mat.freeze();
===================================
Rendering group performance
    // Groups
    ground.renderingGroupId = 0;
    sphere.renderingGroupId = 1;
    box.renderingGroupId = 2;

    // Prevent clear between groups.
    scene.setRenderingAutoClearDepthStencil(1, false);    
    scene.setRenderingAutoClearDepthStencil(2, false);
    // switch back and forth.
    scene.onRenderingGroupObservable.add(function(info) {
        if (info.renderStage === BABYLON.RenderingGroupInfo.STAGE_PREOPAQUE) {
            if (info.renderingGroupId === 1) {
                engine.setDepthFunctionToGreater();
            }
            else if (info.renderingGroupId === 2) {
                engine.setDepthFunctionToLessOrEqual();
            }
        }
    });

====================================

check VR display!!!!!!!!!!!!!!!!!
may need reboot

Find out how to put skybox into its own rendering group

get pjump and plook to work for camera

change camera speed inside a SpaceVolume

Flatten spheres (like Saturn) and bake vertices

swap followCamera for Planets, if not in VR
https://doc.babylonjs.com/babylon101/cameras

play with camera.inertia = 1;
CAMERA > 1 GIVES HYPERSPEED, OUTSIDE UNIVERSE

explore transformnode
https://doc.babylonjs.com/how_to/pivot

// 3D labels billboards (another sprite?)

VR: add 3D haptic controls

explore pivot

SpaceVolume add backface culling

camera acceleration and deceleration

make sure glow layer drawn in same layer as object!!!!

scaling for size of stars, planets in different modes

shadertoy for star surface

pixel shader, determine pixels
https://stackoverflow.com/questions/17339149/webgl-how-do-i-get-the-position-of-every-pixel-in-fragment-shader

stop picked mesh afte first "hit"

make everything "arrow" notation

animation to reset scale when inside planetary system

setLabel (in scene.js)

MergeMeshes() ?

Mesh optimization (simple)

Determine if Sprite is visible

alpha in Sprte shader

Blending of skybox

let textureTask = assetsManager.addEquiRectangularCubeTextureAssetTask('EquiRectangularCubeTextureAssetTask1', 'textures/360photo.jpg', 512);

        textureTask.onSuccess = (task) => {
            texture = task.texture;
            sphereMat.reflectionTexture = texture;
            sphere.material = sphereMat;
        }

        assetsManager.load();



        // CFBDSIR2149
        // https://www.eso.org/public/archives/releases/sciencepapers/eso1245/eso1245a.pdf
        // RA: 21h 49, 47.2s  + motion: 1.2 sec (10 years)
        //Dec: 04d 03m 08.9s  - motion: 1.0 sec (10 years)
        // Dist  31 +/- 13

        // DEC: 
        // RA: 327.44666666666666
        // DEC: 4.052472222222222

                    "planets": [
                            {
                                "key": "cfbdsir2149",
                                "dname": "cfbdsir2149",
                                "name": "CFBDSIR2149",
                                "description": "Free-floating planet in the AB Doradus moving group, 4-7 times Jupiter, 450deg.",
                                "data": {
                                    "type": "free_planet",
                                    "diameter": 2000,
                                    "ra": 5.715109724,
                                    "dec": 4.05219444,
                                    "x": 2,
                                    "y": 1,
                                    "z": 1,
                                    "dist":1,
                                    "color": [1,1,1],
                                    "models": {
                                        "default": {
                                        "surface": "cfbdsir2149-vis.png",
                                        "emissive": "true",
                                        "specular": 1,
                                        "active": true
                                        }
                                    },
                                    "references": [
                                        "https://www.eso.org/public/archives/releases/sciencepapers/eso1245/eso1245a.pdf"
                                    ],
                                    "moons": [],
                                    "artifacts": []
                                }
                        }
                    ]


https://en.wikipedia.org/wiki/Rogue_planet

PSO J318.5338âˆ’22.8603
https://iopscience.iop.org/article/10.1088/2041-8205/777/2/L20



case t.FREE_PLANET:
                    // don't have a parent star system, so don't set with local vector using
                    // the stellar scale
                    //mesh.setPositionWithLocalVector(new BABYLON.Vector3(scaled.dist, 0, 0));
                    this.loadSpaceVolume(pObj, dir, scene);
                    this.setPosition(data, mesh.position, dParsecUnits);

                    // appearance
                    console.log("TEXTURE DIR:" + texDir + model.surface)
                    mat.diffuseTexture = new BABYLON.Texture(texDir + model.surface, scene);
                    mat.emissiveColor = new BABYLON.Color3(1, 1, 1);

                                            // glow
                        var gll = new BABYLON.GlowLayer('glow', scene, options);
                        gll.intensity = 5;
                        mat.emissiveColor = new BABYLON.Color3(0.678, 0.556, 0.423);
                        // TODO: explore emissive color for glow.
                        //////////////mat.emissiveColor = clr.clone();
                        gll.addIncludedOnlyMesh(mesh);

                    if(util.isNumber(model.specular)) {
                        mat.specularColor = new BABYLON.Color3(model.specular, model.specular, model.specular)
                    } else {
                        mat.specularColor = new BABYLON.Color3(0, 0, 0)
                    }
                    break;


{
	"AbsMag":"0.615",
	"Dec":"31.888276",
	"Distance":"15.5958",
	"HD":"60179",
	"HR":"2891",
	"Hip":"36850",
	"Mag":"1.58",
	"ProperName":"Castor",
	"RA":"7.576634",
	"Spectrum":"A2Vm",
	"StarID":"36744",
	"x":"-5.311938",
	"y":"12.130011",
	"z":"8.238737"
},
{
	"AbsMag":"8.950",
	"Dec":"31.888276",
	"Distance":"",
	"HD":"",
	"HR":"",
	"Hip":"329",
	"Mag":"9.83",
	"ProperName":"Castor C (YY Gem)",
	"RA":"7.577222",
	"Spectrum":"M0.5VeFe-2",
	"StarID":"",
	"x":"",
	"y":"",
    "z":"",
    "ref": ""
},
{
	"AbsMag":"-5.028",
	"Dec":"01 56 35.58704",
	"Distance":"225.7336",
	"HD":"37742",
	"HR":"1948",
	"Hip":"26727",
	"Mag":"1.74",
	"ProperName":"Alnitak B",
	"RA":"05 40 45.571207",
	"Spectrum":"O9.5Ib SB",
	"StarID":"26662",
	"x":"18.918488",
	"y":"224.809409",
	"z":"-7.651875"
},

https://en.wikipedia.org/wiki/Luhman_16

https://en.wikipedia.org/wiki/Luhman_16

// separated by: 0.00625 

{
	"AbsMag":"13.78",
	"Dec":"-53.31941",
	"Distance":"1.9980",
	"HD":"",
	"HR":"",
	"Hip":"",
	"Mag":"10.73",
	"ProperName":"Luhman 16 A",
	"RA":"162.3280125",
	"Spectrum":"L7.5",
	"StarID":"",
	"x":"",
	"y":"",
	"z":""
},
{
	"AbsMag":"13.78",
	"Dec":"-53.31941",
	"Distance":"1.9980",
	"HD":"",
	"HR":"",
	"Hip":"",
	"Mag":"10.73",
	"ProperName":"Luhman 16 B",
	"RA":"162.3280125",
	"Spectrum":"T0.5",
	"StarID":"",
	"x":"",
	"y":"",
	"z":""
},

local_group/star_systems/luhman_16/stars/luhman_16_a/textures/luhman_16_a.png
local_group/star_systems/luhman16/stars/luhman_16_a/textures/luhman_16_a.png

{
	"AbsMag":"3.65",
	"Dec":"33.88232912056897",
	"Distance":"229",
	"HD":"",
	"HR":"",
	"Hip":"",
	"Mag":"10.42",
	"ProperName":"WASP-13",
	"RA":"140.10296541950603",
	"Spectrum":"G1 V",
	"StarID":"",
	"x":"",
	"y":"",
	"z":""
},


*/


////////////////////////////////////////////////////////////////////////////////////////
/*
        var createPScene = async function (engine) {

            let canvas = engine.getRenderingCanvas();

            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);

            // This creates and positions a free camera (non-mesh)
            let camera = new BABYLON.UniversalCamera('desktopcamera', new BABYLON.Vector3(0, 0, 19), scene);

            // This targets the camera to scene origin
            camera.setTarget(BABYLON.Vector3.Zero());

            console.log('rendering canvas is:' + engine.getRenderingCanvas())
        
            // This attaches the camera to the canvas
            camera.attachControl(canvas, true);

            // IMPORTANT: you CANNOT add camera to scene.activeCameras

            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        
            // Default intensity is 1. Let's dim the light a small amount
            light.intensity = 0.7;
        
            // Our built-in 'sphere' shape.
            var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2, segments: 32}, scene);
        
            // Move the sphere upward 1/2 its height
            sphere.position.y = 1;
        
            const environment = scene.createDefaultEnvironment();
        
            // XR
            const xrHelper = await scene.createDefaultXRExperienceAsync({
                //floorMeshes: [environment.ground]
            }).then(helper => {
                helper.baseExperience.onStateChangedObservable.add((state) => {

                switch(state) {

                    case BABYLON.WebXRState.ENTERING_XR:
                        console.log("Entering XR:" + state)
                        //pWorld.toggleVRSkybox(true); // shrunken below 1000 unit size
                        break;

                    case BABYLON.WebXRState.IN_XR:
                        // XR is initialized and already submitted one frame
                        console.log("In XR:" + state)
                        break;

                    case BABYLON.WebXRState.EXITING_XR:
                        console.log("Exiting XR:" + state)
                        //pWorld.toggleVRSkybox(false); // original size
                        break;

                    case BABYLON.WebXRState.NOT_IN_XR:
                        console.log("Not in XR:" + state)
                        // self explanatory - either our or not yet in XR
                        break;

                }

            });

        });

        return scene;
        
    };

    let engine = plutonianWorld.setup.createDefaultEngine();

    if(engine.getRenderingCanvas()) {

        // initialize loader UI
        engine.loadingScreen = new customLoadingScreen('scene-loader-wrapper', 'scene-loader-dialog');

        // display Loading Screen
        engine.loadingScreen.displayLoadingUI();

        let sc = createPScene(engine).then(returnedScene => { 

            // hide the startup screen
            returnedScene.getEngine().loadingScreen.hideLoadingUI();

            engine.runRenderLoop( function () {

                if (returnedScene) {
                    returnedScene.render();
                }

            });

            // Resize
            window.addEventListener("resize", function () {
                engine.resize();
            });

        });

    } // valid engine

    */


////////////////////////////////////////////////////////////////////////////////////////
/**
 * Fire loading
 */

/*

try {

    // Initialize BABYLON, then attach <canvas> as rendering surface

    // create rendering engine
    let eng = plutonianWorld.setup.createDefaultEngine().then((returnedEngine) => {

        if(returnedEngine) {

            let engine = returnedEngine;

            // initialize loader UI
            engine.loadingScreen = new customLoadingScreen('scene-loader-wrapper', 'scene-loader-dialog');

            // display Loading Screen
            engine.loadingScreen.displayLoadingUI();

            // create the scene (async)
            var s = plutonianWorld.createScene(engine).then(returnedScene => { 

            // keep a local copy
            plutonianWorld.scene = returnedScene;

            returnedScene.getEngine().loadingScreen.hideLoadingUI();

            // Optimization
            // TODO: put skybox into its own rendering group
            // NOTE: there's probably a way to put this into rendering groups
            // scene.autoClear = false; // Color buffer
            // scene.autoClearDepthAndStencil = false; // Depth and stencil, obviously
            // scene.setRenderingAutoClearDepthStencil(renderingGroupIdx, autoClear, depth, stencil);

            // load assets into the scene
            var assets = plutonianWorld.createAssets(returnedScene).then(returnedAssets => {

                console.log('in .then for createAssets()');

                // Make some items pickable
                returnedScene.onPointerDown = function (evt) {

                    let pickResult = this.pickSprite(this.pointerX, this.pointerY);

                    if (pickResult.hit) {
                        if(pickResult.pickedSprite) {
                            console.log("Picked sprite is:" + pickResult.pickedSprite.name + " id:" + pickResult.pickedSprite.hygid)
                            window.sprite = pickResult.pickedSprite; // TODO: remove
                            // NOTE: default camera wash pushed into array when the camera was created
                            let cam = this.activeCameras[0];
                            let dx = cam.position.x - sprite.position.x,
                            dy = cam.position.y - sprite.position.y,
                            dz = cam.position.z - sprite.position.z;
                            let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                            console.log("distance:" + dist + " sizeX:" + pickResult.pickedSprite.width)
                        }
                    }

                    let pickMesh = this.pick(this.pointerX, this.pointerY);
                    if(pickMesh.hit) {
                        let m = pickMesh.pickedMesh;
                        console.log("Picked mesh is:" + m.name);
                        window.mesh = m;
                        //if(!m.infiniteDistance) {
                        //    console.log("Changing mesh::::")
                        //    toggleMeshActivation(m)
                        //};

                    }

                };

            }); // end of asset loading

            //sceneToRender = returnedScene;
                // set up endless render loop
            engine.runRenderLoop(function () {
                if (returnedScene) {
                    returnedScene.render();
                }

            }); // end of rendering loop

        }); // end of createScene=>then

        } // if engine was created


    }); // end of createEngine=>then

} catch (e) {

    console.error('failed setup...');
    if (e instanceof SyntaxError) {

        util.printError(e, true);

        } else {

            util.printError(e, false);

        }

}

*/



PWorld.prototype.createScene = async function (engine) {

    let pWorld = this;
    let celestial = this.celestial;

    let canvas = engine.getRenderingCanvas();

    // This creates a basic Babylon Scene object (non-mesh)
    let scene = new BABYLON.Scene(engine);

    if(!engine || !canvas) {
        console.error('createScene ERROR: missing engine:' + engine + ' or canvas:' + camvas);
        return;
    }

    // TODO: Optimizations
    // https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer

    // TODO: follow camera
    // https://doc.babylonjs.com/babylon101/cameras

    // This creates and positions a free camera (non-mesh)
    //var camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 0, 19), scene);
    let camera = new BABYLON.UniversalCamera('desktopcamera', new BABYLON.Vector3(0, 0, 19), scene);

    camera.maxZ = this.DESKTOP_DEFAULT_SIZE * celestial.dParsecUnits; // constant, size of skybox for visible universe
    camera.minZ = 1;

    console.log('camera initial size is:' + camera.minZ + ', ' + camera.maxZ)

    // This targets the camera to scene origin
    camera.setTarget(BABYLON.Vector3.Zero());

    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);

    // IMPORTANT: YOU CANNOT add camera to scene.activeCameras [] for VR to work!!!!

    //camera.inertia = 1; doesn't stop
    //camera.inertia = 0.1; very short

    // Glow Layer
    var gl = new BABYLON.GlowLayer('glow', scene, {
            mainTextureRatio: 0.1,
            //mainTextureFixedSize: 256,
            blurKernelSize: 100
    });

    gl.intensity = 5;
    this.glow = gl;

    // create a fullscreen UI layer
    /////////scene.gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI');

// adjust rendering pipeline (just for skybox?)
//var quality = "high";
//var pipeline = new BABYLON.DefaultRenderingPipeline("pipeline", false, scene, [camera]); /// name, hdrEnabled, scene, cameras
//if (quality != "low") {
//    pipeline.bloomEnabled = true;
//    pipeline.bloomWeight = 4;
//}
//pipeline.fxaa = new BABYLON.FxaaPostProcess('fxaa', 1, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false);
//pipeline.fxaaEnabled = true; // fxaa deactivated by default

    // TODO: set up controllers for Desktop and VR
    // https://doc.babylonjs.com/how_to/webxr_controllers_support

    /*
     * Set up VR support
     * Also see https://doc.babylonjs.com/playground/?code=customButtons
     */

    // TODO: not used yet. Check when API exposes it.
    const HMDXRButton = document.getElementsByClassName('xr-toggle.button')[0];

    const xrHelperOptions = {
        //floorMeshes: [environment.ground],
        //disableDefaultUI : true
        createDeviceOrientationCamera: false
    };

    // XR
    const xrHelper = await scene.createDefaultXRExperienceAsync(xrHelperOptions).then(helper => {

        helper.baseExperience.onStateChangedObservable.add((state) => {

            switch(state) {

                case BABYLON.WebXRState.ENTERING_XR:
                    console.log("Entering XR:" + state)
                    //pWorld.toggleVRSkybox(true); // shrunken below 1000 unit size
                    break;

                case BABYLON.WebXRState.IN_XR:
                    // XR is initialized and already submitted one frame
                    console.log("In XR:" + state)
                    break;

                case BABYLON.WebXRState.EXITING_XR:
                    console.log("Exiting XR:" + state)
                    //pWorld.toggleVRSkybox(false); // original size
                    break;

                case BABYLON.WebXRState.NOT_IN_XR:
                    console.log("Not in XR:" + state)
                    // self explanatory - either our or not yet in XR
                    break;

            }

        });

    });

    return scene;

};